// Generated by CoffeeScript 1.8.0
(function() {
  var DEFAULTS, FileServer, Validator, fileServer, formidable, fs, http, jade, mime, path, settings, url, validator;

  http = require('http');

  url = require('url');

  path = require('path');

  fs = require('fs');

  mime = require('mime');

  jade = require('jade');

  formidable = require('formidable');

  DEFAULTS = {
    PORT: 8000,
    DIRECTORY: process.cwd(),
    CLIENT_DIR: path.join(__dirname, 'client')
  };

  FileServer = (function() {
    function FileServer(settings) {
      this.publicDir = settings.directory;
      this.port = settings.port;
      this.clientDir = settings.clientDir;
      this.dirIndexTemplate = jade.compileFile(path.join(this.clientDir, 'index.jade'));
      this.errorPageTemplate = jade.compileFile(path.join(this.clientDir, 'error.jade'));
    }

    FileServer.prototype.startServer = function() {
      var httpServer;
      httpServer = http.createServer((function(_this) {
        return function(req, res) {
          var socketData, timeOfRequest, uri;
          uri = url.parse(req.url).pathname;
          uri = unescape(uri);
          socketData = req.socket.address();
          timeOfRequest = _this.getCurrentTime();
          console.log("" + socketData.address + " - " + timeOfRequest + " \"" + req.method + " " + uri + "\"");
          if (req.method === "GET") {
            _this.methodHandlerGET(res, uri);
          } else if (req.method === "POST") {
            _this.methodHandlerPOST(req, res, uri);
          } else {
            _this.sendMethodNotAllowed(res);
          }
        };
      })(this));
      httpServer.listen(this.port);
      console.log("Server serving on port " + this.port);
      console.log("Folder used: " + this.publicDir);
    };

    FileServer.prototype.methodHandlerGET = function(res, uri) {
      var systemPath;
      systemPath = this.uriToSystemPath(uri);
      if (systemPath[systemPath.length - 1] === '/' && systemPath !== '/') {
        systemPath = systemPath.slice(0, systemPath.length - 1);
      }
      if (!systemPath) {
        this.sendErrorNotFound(res);
        return;
      }
      fs.stat(systemPath, (function(_this) {
        return function(err, stats) {
          if (err) {
            _this.sendErrorInternal(res);
          } else if (stats.isFile()) {
            _this.sendFile(res, systemPath);
          } else {
            _this.sendDirIndex(res, systemPath);
          }
        };
      })(this));
    };

    FileServer.prototype.methodHandlerPOST = function(req, res, uri) {
      var fileForm;
      fileForm = new formidable.IncomingForm();
      fileForm.uploadDir = path.join(this.publicDir, uri);
      fileForm.keepExtensions = true;
      fileForm.parse(req, (function(_this) {
        return function(err, fields, files) {
          var existingFilePath, renamedFilePath, uploadedFile;
          uploadedFile = files.uploadedFile;
          existingFilePath = uploadedFile.path;
          if (uploadedFile.name === '') {
            fs.unlink(existingFilePath, function(err) {
              if (err) {
                _this.sendErrorInternal(res);
              } else {
                _this.sendDirIndex(res, _this.uriToSystemPath(uri));
              }
            });
          } else {
            renamedFilePath = path.join(fileForm.uploadDir, uploadedFile.name);
            fs.rename(existingFilePath, renamedFilePath, function(err) {
              if (err) {
                _this.sendErrorInternal(res);
              } else {
                _this.sendDirIndex(res, _this.uriToSystemPath(uri));
              }
            });
          }
        };
      })(this));
    };

    FileServer.prototype.uriToSystemPath = function(uri) {
      var realPath;
      realPath = path.join(this.publicDir, uri);
      realPath = path.normalize(realPath);
      if (realPath.indexOf(this.publicDir) !== 0) {
        return false;
      }
      if (fs.existsSync(realPath)) {
        return realPath;
      } else {
        return false;
      }
    };

    FileServer.prototype.generateIndexHTML = function(path, filesMetaData) {
      return this.dirIndexTemplate({
        path: path,
        filesMetaData: filesMetaData
      });
    };

    FileServer.prototype.genereateErrorHTML = function(errorCode, description) {
      return this.errorPageTemplate({
        errorCode: errorCode,
        errorDescription: description
      });
    };

    FileServer.prototype.sendDirIndex = function(res, systemPath) {
      fs.readdir(systemPath, (function(_this) {
        return function(err, files) {
          var fileSize, fileStats, filesMetaData, i, isDir, parentDir, upDirUri, uri, _i, _j, _ref, _ref1;
          if (err) {
            _this.sendErrorInternal(res);
            return;
          }
          filesMetaData = [];
          for (i = _i = 0, _ref = files.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            fileStats = fs.statSync(path.join(systemPath, files[i]));
            isDir = fileStats.isDirectory();
            if (systemPath === _this.publicDir) {
              parentDir = systemPath.replace(_this.publicDir, '/');
            } else {
              parentDir = systemPath.replace(_this.publicDir, '');
            }
            if (isDir) {
              fileSize = 0;
            } else {
              fileSize = fileStats.size;
            }
            uri = path.join(parentDir, files[i]);
            filesMetaData[i] = {
              name: files[i],
              uri: uri,
              isDir: isDir,
              size: _this.humanSize(fileSize)
            };
          }
          filesMetaData.sort(function(a, b) {
            if (a.isDir) {
              if (b.isDir) {
                return a.name.toLowerCase() > b.name.toLowerCase();
              } else {
                return -1;
              }
            }
            if (b.isDir) {
              return 1;
            }
            return a.name.toLowerCase() > b.name.toLowerCase();
          });
          if (parentDir !== '/') {
            for (i = _j = _ref1 = parentDir.length - 2; _j >= 0; i = _j += -1) {
              if (parentDir[i] === '/') {
                upDirUri = parentDir.slice(0, i);
                upDirUri = upDirUri ? upDirUri : '/';
                filesMetaData.splice(0, 0, {
                  name: 'Go up in directory tree',
                  uri: upDirUri,
                  isDir: true,
                  size: 0
                });
                break;
              }
            }
          }
          res.writeHead(200, {
            'Content-Type': 'text/html'
          });
          res.write(_this.generateIndexHTML(parentDir, filesMetaData));
          res.end();
        };
      })(this));
    };

    FileServer.prototype.humanSize = function(size) {
      var type, types, _i, _len;
      types = ['Bytes', 'KB', 'MB'];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (size < 1024) {
          return "" + (size.toFixed(1)) + " " + type;
        } else {
          size /= 1024;
        }
      }
      return "" + (size.toFixed(1)) + " GB";
    };

    FileServer.prototype.sendFile = function(res, systemPath) {
      var stream;
      stream = fs.createReadStream(systemPath);
      stream.on('open', function() {
        res.writeHead(200, {
          'Content-Type': mime.lookup(systemPath)
        });
        stream.pipe(res, {
          end: true
        });
      });
      stream.on('error', (function(_this) {
        return function(err) {
          _this.sendErrorInternal();
        };
      })(this));
    };

    FileServer.prototype.sendErrorNotFound = function(res) {
      res.writeHead(404);
      res.write(this.genereateErrorHTML(404, "File Not Found"));
      return res.end();
    };

    FileServer.prototype.sendMethodNotAllowed = function(res) {
      res.writeHead(405);
      res.write(this.genereateErrorHTML(405, "Method Not Allowed"));
      return res.end();
    };

    FileServer.prototype.sendErrorInternal = function(res) {
      res.writeHead(500);
      res.write(this.genereateErrorHTML(500, "Internal Server Error"));
      return res.end();
    };

    FileServer.prototype.getCurrentTime = function() {
      var currentTime;
      currentTime = new Date();
      return '[' + currentTime.getFullYear() + '-' + (currentTime.getMonth() + 1) + '-' + (currentTime.getDate()) + ' ' + (currentTime.getHours()) + ':' + (currentTime.getMinutes()) + ':' + currentTime.getSeconds() + ']';
    };

    return FileServer;

  })();

  Validator = (function() {
    function Validator() {}

    Validator.prototype.validateArgs = function() {
      var dir, port;
      dir = process.argv[2] || DEFAULTS.DIRECTORY;
      dir = path.resolve(dir);
      port = process.argv[3] || DEFAULTS.PORT;
      console.log(port);
      if (this.validatePathPort(dir, port)) {
        return {
          directory: dir,
          port: port,
          clientDir: DEFAULTS.CLIENT_DIR
        };
      }
      return false;
    };

    Validator.prototype.validatePathPort = function(dirpath, port) {
      if (!this.validateDir(dirpath)) {
        console.log('Directory path is invalid');
        return false;
      }
      if (!this.validatePort(port)) {
        console.log('Port must be a number between 0 to 65535');
        return false;
      }
      return true;
    };

    Validator.prototype.validateDir = function(dirpath) {
      if (fs.existsSync(dirpath)) {
        return fs.statSync(dirpath).isDirectory();
      }
      return false;
    };

    Validator.prototype.validatePort = function(port) {
      var num;
      num = parseInt(port);
      if (isNaN(num)) {
        return false;
      }
      return num >= 0 && num <= 65535;
    };

    return Validator;

  })();

  validator = new Validator();

  settings = validator.validateArgs();

  if (settings) {
    fileServer = new FileServer(settings);
    fileServer.startServer();
  }

}).call(this);
